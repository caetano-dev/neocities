<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concepts of Programming Languages</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="A summary of general concepts of programming languages">
    <meta name="keywords" content="programming, programming languages, concepts, variables, scope, compile-time">
    <meta name="author" content="Drull">
    <link rel="stylesheet" href="../styles.css" />

    <title>Full OSINT guide | Drull's blog</title>
</head>

<body>
    <main>
        <h1 id="language-structures">Concepts of programming languages</h1>
        <p>This is a summary I have written for a college exam and thought it would be cool to share it here.</p>
        <h2 id="language-levels">Language Levels</h2>
        <h3 id="high-level">High level</h3>
        <p>High-level languages are designed to provide programmers with a convenient development environment and
            control
            abstractions that make it easier to create programs. They have several advantages, such as:</p>
        <p><strong>Benefits:</strong></p>
        <ol>
            <li>
                <p><strong>Ease of Reading and Learning:</strong> The syntax of high-level languages is designed to
                    resemble
                    human language, making the code more readable and accessible to beginners and experienced
                    programmers.
                </p>
            </li>
            <li>
                <p><strong>Productivity:</strong> These languages offer high-level constructs, such as control
                    structures
                    and predefined functions, that allow programmers to write code faster.</p>
            </li>
            <li>
                <p><strong>Portability:</strong> Generally, code written in a high-level language can be easily ported
                    to
                    different platforms as most of the hardware complexity is abstracted.</p>
            </li>
            <li>
                <p><strong>Simplified Maintenance:</strong> The readability and organized structure of high-level code
                    makes
                    maintenance and error identification easier.</p>
            </li>
            <li>
                <p><strong>Global Optimizations:</strong> High-level language compilers and interpreters can perform
                    global
                    optimizations, improving the efficiency of the generated code.</p>
            </li>
        </ol>
        <p><strong>Disadvantages:</strong></p>
        <ol>
            <li>
                <p><strong>Performance:</strong> Compared to low-level languages, high-level languages may have slightly
                    lower performance since the abstraction layer adds overhead.</p>
            </li>
            <li>
                <p><strong>Executable Size:</strong> Programs created in high-level languages can generate larger
                    executables than those written in low-level languages, due to the inclusion of high-level libraries
                    and
                    structures.</p>
            </li>
        </ol>
        <h3 id="low-level">Low level</h3>
        <p>Low-level languages operate closer to the hardware and give programmers more direct control over the machine.
            However, they also present significant challenges.</p>
        <p><strong>Benefits:</strong></p>
        <ol>
            <li>
                <p><strong>Full Control:</strong> Programmers have direct control over memory and hardware resources,
                    allowing for specific optimizations and precise manipulation.</p>
            </li>
            <li>
                <p><strong>Performance:</strong> Low-level languages generally produce highly efficient code, making
                    them
                    ideal for systems that require maximum speed.</p>
            </li>
            <li>
                <p><strong>Lower Overhead:</strong> Code generated in low-level languages tends to have lower overhead
                    compared to high-level languages.</p>
            </li>
        </ol>
        <p><strong>Disadvantages:</strong></p>
        <ol>
            <li>
                <p><strong>Learning Curve:</strong> Programming in low-level languages can be complex and require
                    in-depth
                    knowledge of the hardware, resulting in a steep learning curve.</p>
            </li>
            <li>
                <p><strong>Error Prone:</strong> Direct control over memory and resources increases the chance of errors
                    such as memory leaks and access violations.</p>
            </li>
            <li>
                <p><strong>Limited Portability:</strong> Code written in low-level languages can be highly dependent on
                    the
                    hardware architecture, which makes portability difficult.</p>
            </li>
            <li>
                <p><strong>Slower Development:</strong> Due to the need to deal with low-level details, software
                    development
                    in low-level languages can take longer.</p>
            </li>
        </ol>
        <h2 id="syntax-x-semantics">Syntax x Semantics</h2>
        <p>Syntax concerns the symbols and forms used in a programming language, while semantics deals with the logic
            and
            execution of a program.</p>
        <p>Programming languages can have different syntax and maintain the same semantics and vice versa.</p>
        <p>Example:</p>
        <p>Same syntax, but different semantics.</p>
        <p>In Python2</p>
        <pre><code class="lang-py">&gt;&gt;&gt;<span class="hljs-number">1</span>/<span class="hljs-number">2</span>
<span class="hljs-number">0</span>
</code></pre>
        <p>In Python3</p>
        <pre><code class="lang-py">&gt;&gt;&gt;<span class="hljs-number">1</span>/<span class="hljs-number">2</span>
<span class="hljs-number">0.5</span>
</code></pre>
        <p>Same semantics, but different syntax.</p>
        <p>In Moon</p>
        <pre><code class="lang-moon">&gt;&gt;<span class="hljs-type">list</span> = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}
&gt;&gt;print(#<span class="hljs-type">list</span>)
<span class="hljs-number">3</span>
</code></pre>
        <p>In Python</p>
        <pre><code class="lang-py">&gt;&gt;&gt;<span class="hljs-type">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
&gt;&gt;&gt;print(len(<span class="hljs-type">list</span>))
<span class="hljs-number">3</span>
</code></pre>
        <h2 id="expressiveness">Expressiveness</h2>
        <p>Language A is strictly more expressive than language B if both of the following statements are true:</p>
        <ul>
            <li>Any program written in language B can be rewritten in language A, keeping the essential structure of the
                program intact.</li>
            <li>Some programs written in language A need to be violently restructured so that they can be written in
                language B.</li>
        </ul>
        <h2 id="variables-and-binding">Variables and binding</h2>
        <p>Variables allow us to store and manipulate data.</p>
        <h3 id="variable-declaration">Variable declaration</h3>
        <p>When a variable is declared, the computer allocates memory space and defines a name for the variable.</p>
        <h3 id="assignment">Assignment</h3>
        <p>Once a variable is declared, you can assign a value to it. This is the process of binding the variable to a
            specific data value. The value can be of various types such as numbers, strings or complex data structures
            such
            as arrays or objects.</p>
        <h3 id="dynamic-typing-vs-dynamic-typing-static">Dynamic typing vs. dynamic typing static</h3>
        <p>Languages can be categorized into those with dynamic typing and those with static typing.</p>
        <h4 id="dynamic-typing">Dynamic Typing</h4>
        <p>In <strong>dynamically typed languages</strong>, the type of a variable is determined at
            <strong>runtime</strong>, which allows flexibility but can lead to runtime errors.
        </p>
        <h4 id="static-typing">Static Typing</h4>
        <p>In <strong>statically typed languages</strong>, the type of the variable must be declared at <strong>compile
                time</strong>, offering automatic detection of errors, but with stricter rules.</p>
        <h3 id="strong-typing-vs-strong-typing-weak-typing">Strong Typing vs. Strong Typing Weak Typing</h3>
        <p>In addition to the distinction between dynamic and static typing, programming languages can also be
            classified
            based on <strong>typing strength</strong>. Strong typing and weak typing are concepts related to the
            rigidity of
            type conversion rules in a language.</p>
        <h4 id="strong-typing">Strong Typing</h4>
        <p>In strongly typed programming languages, conversions between data types are strictly regulated and limited.
            This
            means that operations involving different types require that the types be compatible according to
            well-defined
            rules. Any attempt to perform an operation between incompatible types will result in an error.</p>
        <p>Example in Python (strong typing):</p>
        <pre><code class="lang-python"><span class="hljs-attr">a</span> = <span class="hljs-number">5</span>
<span class="hljs-attr">b</span> = <span class="hljs-string">"10"</span>

<span class="hljs-comment"># This operation will result in an error as int and str are not compatible</span>
<span class="hljs-attr">c</span> = a + b
</code></pre>
        <p>In this example, trying to add an integer (<code>a</code>) to a string (<code>b</code>) causes a type error,
            because strong typing does not allow this implicit conversion.</p>
        <h4 id="weak-typing">Weak Typing</h4>
        <p>In weakly typed programming languages, conversions between data types are more flexible. Operations between
            different types can be performed with fewer restrictions, and in some cases type conversions are done
            automatically by the system, even though this can lead to unexpected results.</p>
        <p>Example in JavaScript (weak typing):</p>
        <pre><code class="lang-javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span>;
<span class="hljs-keyword">var</span> b = <span class="hljs-string">"10"</span>;

// <span class="hljs-type">JavaScript</span> allows <span class="hljs-built_in">string</span> <span class="hljs-keyword">and</span> number concatenation <span class="hljs-keyword">without</span> error
<span class="hljs-keyword">var</span> c = a + b; // <span class="hljs-type">The</span> <span class="hljs-literal">result</span> will be the <span class="hljs-built_in">string</span> <span class="hljs-string">"510"</span>
</code></pre>
        <p>In this example, in JavaScript (a weakly typed language), adding a number (<code>a</code>) to a string
            (<code>b</code>) results in the concatenation of the values, as weak typing allows this implicit conversion.
        </p>
        <h4 id="contrast-with-dynamic-and-static-typing">Contrast with Dynamic and Static Typing</h4>
        <p>It is important to note that strong typing and weak typing relate to the way languages handle type coercion
            during program execution, while dynamic and static typing relate to the way types are checked at run or
            compile
            time. .</p>
        <ul>
            <li>
                <p><strong>Strong typing with static typing:</strong> Requires that types are compatible, and these
                    checks
                    are performed at compile time. Example: Java.</p>
            </li>
            <li>
                <p><strong>Strong typing with dynamic typing:</strong> Requires types to be compatible, but these checks
                    are
                    performed at runtime. Example: Python.</p>
            </li>
            <li>
                <p><strong>Weak typing with static typing:</strong> Allows more flexible conversions, but still requires
                    type declaration at compile time. Example: C.</p>
            </li>
            <li>
                <p><strong>Weak typing with dynamic typing:</strong> Allows flexible conversions and runtime checks.
                    Example: JavaScript.</p>
            </li>
        </ul>
        <p>The choice between strong and weak typing, along with dynamic or static typing, affects the way type errors
            are
            handled, the flexibility of the code, and the ease of development, and is one of the important aspects to
            consider when choosing a language. programming for a specific project.</p>
        <h2 id="variable-scope">Variable scope</h2>
        <h3 id="local-vs-local-variables-global">Local vs. local variables global</h3>
        <p>Variables can have different scopes, which determine where in the code they can be accessed:</p>
        <ul>
            <li>
                <p><strong>Local variables:</strong> They are limited to a specific block or function and can only be
                    accessed within that scope. They generally have a shorter lifespan and are destroyed when the block
                    is
                    closed.</p>
            </li>
            <li>
                <p><strong>Global variables:</strong> They have a broader scope and can be accessed from anywhere in the
                    code. They are usually declared outside of functions and have a longer useful life.</p>
            </li>
        </ul>
        <h2 id="variable-tying">Variable tying</h2>
        <h3 id="passing-by-value-vs-pass-by-reference">Passing by value vs. pass by reference</h3>
        <p>In some programming languages, variables are bound to values, while in others, they are bound to references.
            This
            difference affects how data is handled:</p>
        <ul>
            <li>
                <p><strong>Pass by value:</strong> When a variable is bound to a value, changing the value of the
                    variable
                    does not affect other variables with the same initial value.</p>
            </li>
            <li>
                <p><strong>Pass by reference:</strong> When a variable is bound to a reference, it points to the same
                    memory
                    location as the original variable. Changes made to one variable affect all variables that reference
                    the
                    same data.</p>
            </li>
        </ul>
        <h3 id="immutable-variables">Immutable variables</h3>
        <p>With immutable variables, once a value is assigned to a variable, it cannot be changed. Instead, any
            modification
            creates a new variable with the updated value. This helps avoid unintended side effects and increases code
            predictability.</p>
        <h2 id="stages-of-program-execution">Stages of program execution</h2>
        <h3 id="language-design-time">Language design time</h3>
        <h4 id="goal">Goal</h4>
        <p>Language design time is the initial phase in which the programming language itself is conceived and
            developed.
            During this stage, language designers and architects create the syntax, semantics, and features of a new
            programming language. The aim is to create a language that is expressive, efficient and suitable for a
            specific
            range of languages.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Define the grammar and syntax of the language.</li>
            <li>Design data structures and control flow mechanisms.</li>
            <li>Specification of rules for variable declarations, scope and binding.</li>
            <li>Determine the language&#39;s type system and memory management policies.</li>
            <li>Establishment of the standard library and language APIs.</li>
        </ul>
        <h3 id="implementation-time">Implementation time</h3>
        <h4 id="goal">Goal</h4>
        <p>Implementation time involves actually writing code in the chosen programming language to create a software
            application. This phase focuses on transforming a conceptual design into a working program that can run on a
            computer.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Write the source code using the syntax and features of the language.</li>
            <li>Development of algorithms and data structures to solve specific problems.</li>
            <li>Test and debug code to identify and fix errors.</li>
            <li>Profiling and optimizing code to improve performance.</li>
            <li>Integration of third-party libraries and dependencies as needed.</li>
        </ul>
        <h3 id="preprocessing">Preprocessing</h3>
        <h4 id="goal">Goal</h4>
        <p>The preprocessing phase is optional and mainly applies to languages such as C and C++. It involves
            manipulating
            the source code before compilation to prepare it for translation into machine code.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Inclusion of header files and macro expansion.</li>
            <li>Conditional compilation based on preprocessor directives.</li>
            <li>Removing comments and white spaces.</li>
            <li>Code generation for specific language features.</li>
        </ul>
        <h3 id="compilation">Compilation</h3>
        <h4 id="goal">Goal</h4>
        <p>Compilation translates the source code into an intermediate representation or machine code that can be
            executed
            by the computer&#39;s processor. The result is typically a binary or bytecode executable, depending on the
            language.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Lexical analysis: Tokenization of source code into meaningful units.</li>
            <li>Syntax analysis: Parse tokens to form a syntax tree or intermediate representation.</li>
            <li>Semantic analysis: Checking for type, scope and correction errors.</li>
            <li>Code generation: Production of machine code or bytecode from the intermediate representation.</li>
        </ul>
        <h3 id="lashing">Lashing</h3>
        <h4 id="goal">Goal</h4>
        <p>In languages that support modular programming and separate compilation, the tying phase combines multiple
            compiled modules (object files) into a single executable program. It resolves references between modules and
            libraries.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Symbol resolution: Association of references to functions and variables with their definitions.</li>
            <li>Address binding: Assigning memory addresses to program elements.</li>
            <li>Generation of the final executable file or dynamic libraries.</li>
        </ul>
        <h3 id="loading">Loading</h3>
        <h4 id="goal">Goal</h4>
        <p>Loading places the executable program in memory, making it ready for execution. This phase allocates memory
            space, resolves addresses, and prepares the program for execution.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Memory allocation for code, data and stack segments.</li>
            <li>Resolution of dynamic mooring, if applicable.</li>
            <li>Configuration of program control structures.</li>
        </ul>
        <h3 id="runtime">Runtime</h3>
        <h4 id="goal">Goal</h4>
        <p>The runtime phase covers the actual execution of the program. The program interacts with the operating
            system,
            hardware, and external resources to perform its intended tasks.</p>
        <h4 id="activities">Activities</h4>
        <ul>
            <li>Execute the main function or entry point of the program.</li>
            <li>Handling user input and external data.</li>
            <li>Manage memory, resources and concurrency.</li>
            <li>Performing I/O operations and interfacing with hardware.</li>
        </ul>
        <h2 id="scope">Scope</h2>
        <p>Scope, in programming languages, refers to the part of the program where a variable or identifier can be
            accessed
            and used. It defines the rules that determine the visibility and lifetime of variables, functions, and other
            elements within a program.</p>
        <h3 id="variable-scope">Variable scope</h3>
        <h4 id="local-variables">Local variables</h4>
        <p>Local variables have a restricted scope to a specific block of code, usually delimited by curly braces (as in
            functions or conditional structures). This means that they can only be accessed within that block and are
            destroyed when the block is closed. Local variables are useful for avoiding name conflicts and managing
            memory
            efficiently.</p>
        <pre><code class="lang-python">def <span class="hljs-built_in">example</span>():
     x = <span class="hljs-number">10</span> # Local variable
     <span class="hljs-built_in">print</span>(x)

<span class="hljs-built_in">example</span>()
<span class="hljs-built_in">print</span>(x) # This will result <span class="hljs-keyword">in</span> an <span class="hljs-built_in">error</span> as x <span class="hljs-built_in">is</span> <span class="hljs-keyword">not</span> defined <span class="hljs-keyword">in</span> this scope
</code></pre>
        <h4 id="global-variables">Global variables</h4>
        <p>Global variables have a broader scope and can be accessed from anywhere in the code, including functions.
            They
            are usually declared outside of functions and have a lifetime throughout the execution of the program.
            However,
            excessive use of global variables can make code less readable and more prone to errors.</p>
        <pre><code class="lang-python">y = <span class="hljs-number">20</span> <span class="hljs-comment"># Global variable</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">()</span>:</span>
     print(y) <span class="hljs-comment"># It is possible to access the global variable within the function</span>

example()
print(y) <span class="hljs-comment"># The global variable y can also be accessed out of the function.</span>
</code></pre>
        <h3 id="scope-of-functions">Scope of functions</h3>
        <p>Functions also have their own scope. This means that variables declared inside a function are local to that
            function and cannot be accessed outside of it unless they are returned. This helps encapsulate behavior and
            avoid name conflicts between functions.</p>
        <pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greeting</span><span class="hljs-params">()</span>:</span>
     message = <span class="hljs-string">"Hello world!"</span> <span class="hljs-comment"># Variable local to the function</span>
     <span class="hljs-keyword">return</span> message

print(greeting()) <span class="hljs-comment"># Calling the function and printing its output</span>

<span class="hljs-comment"># Trying to access message here would result in an error as it is outside the scope of the function</span>
</code></pre>
        <h3 id="nested-scope">Nested scope</h3>
        <p>In some languages, it is possible to have nested scopes, where one scope is contained within another. This
            means
            that variables declared in an inner scope can shadow variables with the same name in outer scopes.</p>
        <pre><code class="lang-python">x = <span class="hljs-number">30</span> <span class="hljs-comment"># Global variable</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">()</span>:</span>
     x = <span class="hljs-number">40</span> <span class="hljs-comment"># Variable local to the function, shadows the global variable</span>
     print(x)

example()
print(x) <span class="hljs-comment"># The global variable x remains unchanged</span>
</code></pre>
        <h3 id="dynamic-vs-dynamic-scope-static-scope">Dynamic vs. dynamic scope static scope</h3>
        <p>The way scope is handled can vary between programming languages. Some languages, such as Python, use static
            scoping, where the scope of a variable is determined in the static analysis phase, during code compilation
            or
            interpretation. Other languages, such as JavaScript, use dynamic scoping, where the scope of a variable is
            determined at runtime, based on the function call stack.</p>
        <h2 id="memory-management-stacks-and-stack-overflow">Memory Management, Stacks and Stack Overflow</h2>
        <p>Memory management affects a program&#39;s efficiency, stability, and security.</p>
        <h3 id="computer-memory">Computer Memory</h3>
        <p>A computer&#39;s memory stores data and instructions for executing programs. This memory is divided into
            several
            distinct regions, two of the most important of which are the <strong>stack</strong> (stack) and the
            <strong>heap</strong>.
        </p>
        <h4 id="stack">Stack</h4>
        <p>The stack is a region of memory that stores information about the execution of functions and methods. Each
            time a
            function is called, a new &quot;stack frame&quot; is created, which contains information such as local
            variables, return addresses, and other control data. The stack follows a last-in, first-out (LIFO) data
            structure, which means that the most recently called function is the first to complete.</p>
        <p>The stack is generally small in size and has a hard limit. This means that if many functions are nested or if
            the
            local memory allocation is large, a stack overflow can occur, which is an error that occurs when the stack
            exceeds its limit.</p>
        <p>####Heap</p>
        <p>The heap is a region of memory used to dynamically allocate data during the execution of a program. Unlike
            the
            stack, the heap has no LIFO structure and does not have a fixed limit (other than the physical limit of
            system
            memory).</p>
        <p>The allocation of memory on the heap is controlled manually by the programmer or by a memory management
            system.
            Data allocated to the heap remains there until explicitly freed, which can lead to memory leak issues if the
            free is not done correctly.</p>
        <h3 id="stack-overflow">Stack Overflow</h3>
        <p><strong>stack overflow</strong> is an error that occurs when the stack exceeds its limit. This usually
            happens
            when a function calls itself repeatedly (infinite recursion) or when a program nests many functions, each
            with a
            large local memory usage. When a stack overflow occurs, the program usually terminates abruptly.</p>
        <p>Preventing stack overflow involves consciously using recursion and controlling stack size. For deep
            recursions,
            considering optimizing the algorithm or converting the recursion to an iterative approach may be a solution.
        </p>
        <h3 id="memory-management">Memory Management</h3>
        <p>Memory management is the practice of allocating and freeing memory efficiently and safely during the
            execution of
            a program. The operating system plays a key role in memory management, providing essential services such as:
        </p>
        <ol>
            <li>
                <p><strong>Memory Allocation:</strong> The operating system allocates blocks of memory to running
                    programs,
                    including stack and heap allocators.</p>
            </li>
            <li>
                <p><strong>Free Up Memory:</strong> When memory is no longer needed, it must be freed to prevent memory
                    leaks. The operating system manages this release.</p>
            </li>
            <li>
                <p><strong>Memory Protection:</strong> The operating system protects memory to prevent a program from
                    accessing unauthorized memory areas, which can result in segmentation errors.</p>
            </li>
            <li>
                <p><strong>Memory Swap:</strong> When physical memory is exhausted, the operating system can use
                    techniques
                    such as paging or swapping to move data between main memory (RAM) and the hard drive.</p>
            </li>
        </ol>
        <h2 id="performance-comparison-between-programming-languages">Performance Comparison between Programming
            Languages
        </h2>
        <p>Formally stating that one language performs better than another is a complex task, due to the following
            factors.
        </p>
        <ol>
            <li>Diversity of Applications</li>
        </ol>
        <p>Programming languages are created with varying purposes and usage scenarios in mind. Some languages are
            optimized
            for specific tasks, such as text manipulation (Python), signal processing (MATLAB), or web development
            (JavaScript). Therefore, the performance of a language can vary significantly depending on the context in
            which
            it is used.</p>
        <ol>
            <li>Varied Implementations</li>
        </ol>
        <p>Each programming language has multiple implementations, often developed by different groups and
            organizations.
            For example, Python has implementations like CPython, Jython and IronPython. Each of these implementations
            may
            have different features and optimizations, which affect performance. Therefore, it is difficult to
            generalize
            the performance of &quot;Python&quot; as a whole.</p>
        <ol>
            <li>Compiler and Interpreter Optimizations</li>
        </ol>
        <p>The efficiency of a language also depends on the optimizations performed by the compiler (in compiled
            languages)
            or the interpreter (in interpreted languages). The quality of these optimizations varies from one
            implementation
            to another and can substantially affect performance.</p>
        <ol>
            <li>Algorithm Dependency</li>
        </ol>
        <p>The performance of a program largely depends on the algorithms and data structures used. Choosing the right
            algorithm can have a much greater impact on performance than choosing the language. Two programs written in
            the
            same language can have drastically different performance due to the efficiency of the algorithms used.</p>
        <h2 id="interpreted-languages-vs-compiled">Interpreted Languages vs. Compiled</h2>
        <p>Programming languages can be divided into two main categories: interpreted languages and compiled languages.
        </p>
        <h3 id="compiled-languages">Compiled Languages</h3>
        <h4 id="-what-are-compiled-languages-"><strong>What are Compiled Languages?</strong></h4>
        <p>In compiled languages, source code written by the programmer is translated by a compiler into machine code or
            intermediate code that is executed directly by hardware. This means that, before the program is executed,
            all
            the code is translated and transformed into a form that can be directly executed by the computer.</p>
        <h4 id="-advantages-of-compiled-languages-"><strong>Advantages of Compiled Languages:</strong></h4>
        <ol>
            <li>
                <p><strong>Performance:</strong> Generally, compiled programs tend to have higher performance since the
                    code
                    is optimized during compilation.</p>
            </li>
            <li>
                <p><strong>Compile-Time Error Detection:</strong> Syntax and type errors are caught during compilation,
                    which helps to avoid many run-time errors.</p>
            </li>
            <li>
                <p><strong>Efficient Execution:</strong> The compiled code is executed directly by the hardware, without
                    the
                    overhead of an interpreter, making it more efficient in terms of using system resources.</p>
            </li>
            <li>
                <p><strong>Source Code Protection:</strong> Because source code is not required for execution, compiled
                    programs are often more difficult to revert to their original form, which can increase security.</p>
            </li>
        </ol>
        <h4 id="-disadvantages-of-compiled-languages-"><strong>Disadvantages of Compiled Languages:</strong></h4>
        <ol>
            <li>
                <p><strong>Slower Development:</strong> The need to compile the code before execution can increase
                    development time.</p>
            </li>
            <li>
                <p><strong>Lack of Portability:</strong> Compiled code is often platform-specific, which can make
                    portability to different systems difficult.</p>
            </li>
        </ol>
        <h3 id="interpreted-languages">Interpreted Languages</h3>
        <h4 id="-what-are-interpreted-languages-"><strong>What are Interpreted Languages?</strong></h4>
        <p>In interpreted languages, source code is executed directly by an interpreter, line by line. The interpreter
            translates and executes the code in real time, rather than generating a separate executable program.</p>
        <h4 id="-advantages-of-interpreted-languages-"><strong>Advantages of Interpreted Languages:</strong></h4>
        <ol>
            <li>
                <p><strong>Rapid Development:</strong> Direct execution of the source code simplifies the development
                    process as there is no need to wait for compilation.</p>
            </li>
            <li>
                <p><strong>Portability:</strong> Generally, interpreted programs are more portable, as the interpreter
                    can
                    be implemented on multiple platforms.</p>
            </li>
            <li>
                <p><strong>Ease of Debugging:</strong> The interpreter can provide more informative error messages
                    during
                    execution, making debugging easier.</p>
            </li>
            <li>
                <p><strong>Flexibility:</strong> Real-time execution allows introspection, that is, the ability to
                    inspect
                    and modify the code itself during execution.</p>
            </li>
        </ol>
        <h4 id="-disadvantages-of-interpreted-languages-"><strong>Disadvantages of Interpreted Languages:</strong></h4>
        <ol>
            <li>
                <p><strong>Relative Performance:</strong> Interpreted programs generally have lower performance compared
                    to
                    compiled programs due to interpreter overhead.</p>
            </li>
            <li>
                <p><strong>Lack of Source Code Protection:</strong> Because source code is necessary for execution,
                    interpreted programs may be more susceptible to reverse engineering and unauthorized appropriation.
                </p>
            </li>
            <li>
                <p><strong>Less Detection of Errors at Compile Time:</strong> Syntax and type errors are only detected
                    during execution, which can lead to runtime errors.</p>
            </li>
        </ol>
    </main>
</body>

</html>